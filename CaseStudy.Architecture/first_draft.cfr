abstract Component

abstract Flow
    start -> SoftwareComponent
    end -> SoftwareComponent
    rate ->> integer
    bus -> Bus ? // the bus that implements the flow
    [bus => (this in bus.flows)]

// =====================================================================
// Primitive types: SoftwareComponent, HardwareComponent and Bus
// =====================================================================

abstract SoftwareComponent: Component
    target -> HardwareComponent  // hardware this software component is mapped to
    [this in target.software]  // inverse relationship constraint

abstract HardwareComponent: Component
    software -> SoftwareComponent* // the software it contains
        [this.target = HardwareComponent] // inverse relationship constraint

    mappable?
    [no mappable => no software]
    cost ->> integer // every hardware component has a cost

abstract Bus : HardwareComponent
    [no mappable]
    capacity ->> integer
    flows -> Flow* // an inverse sowing what flows the bus implements
        [this.bus = Bus]  // inverse relationship constraint

    components -> HardwareComponent* // the components the bus connects
    [components = flows.start.target ++ flows.end.target]

abstract SoftwareTopology: Component
    components -> SoftwareComponent*
    flows -> Flow*

//=============================================
// Custom types
//=============================================

abstract ECU : HardwareComponent
    [mappable]

abstract Device : HardwareComponent

abstract NormalSensor : Device
    [no mappable]

abstract SmartSensor : Device
    [mappable]

//----------------------------------------------

abstract SoftwareControl : SoftwareComponent
    ram ->> integer

abstract ECUWithRAM : ECU
    ram ->> integer

//----------- constraints --------------------

[all b : Bus | (sum b.flows.rate) <= b.capacity] // bus capacity constraint
[all c : SoftwareTopology | all flow: c.flows | 
    ( !flow.bus && (flow.start.target = flow.end.target)) // located on the same ECU, and there is no bus
    || 
    (  flow.bus && (flow.start.target in flow.bus.components) && (flow.end.target in flow.bus.components))] 
        // communicating through a bus

//==================================
// Concrete instances
//==================================

// Hardware: 

DoorController : ECUWithRAM
    [ram = 16]
    [cost = 8]

DoorController2 : ECUWithRAM
    [ram = 32]
    [cost = 10]

SmartDoorSensor : SmartSensor
    [cost = 5]

LINBus : Bus
    [cost = 2]
    [capacity = 10]

// Software: 

DoorSensorSoftware: SoftwareComponent
//    [target = SmartDoorSensor]

PowerWindowControl: SoftwareControl
    [target in ECU]
    typecastedTarget -> ECUWithRAM
    [typecastedTarget = target]
    [this.ram <= typecastedTarget.ram]
    [ram = 16]

RequiredSoftwareTopology: SoftwareTopology

    flowFromSensorToPWControl : Flow
        [start = DoorSensorSoftware]
        [end = PowerWindowControl]
        [rate = 8]

    [components = DoorSensorSoftware, PowerWindowControl]
    [flows = flowFromSensorToPWControl]
